#version 430 core

layout(local_size_x = 64) in; //64 Seems to be normal, I don't know too much about this stuff

uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform float W;
uniform float H;
uniform float focal_x;
uniform float focal_y;
uniform float tan_fovx;
uniform float tan_fovy;

struct Splat {
  vec3 position;
  vec3 normal;
  float f_values[45]; // Coefficients for a Spherical Harmonics
                               // function defining color
  float opacity;
  float covariance[6];
};

struct ComputeOutput {
  vec3 transformedPosition;
  vec3 cov;
  vec3 conic;
  vec4 color;
};

// SSBO to store original splat data
layout(std430, binding = 0) buffer Splats {
  Splat splats[];
};

// SSBO to store transformed splat positions
layout(std430, binding = 1) buffer TransformedSplats {
  ComputeOutput computedSplats[];
};


// This function is from a paper on computing Spherical Harmonics
//Peter-Pike Sloan, Efficient Spherical Harmonic Evaluation, Journal of Computer Graphics Techniques (JCGT), vol. 2, no. 2, 84-90, 2013 Available online http://jcgt.org/published/0002/02/06/

float[9] SHNewEval3(const float fX, const float fY, const float fZ) {
  float fC0, fC1, fS0, fS1, fTmpA, fTmpB, fTmpC;
  float fZ2 = fZ * fZ;
  float pSH[9];
  pSH[0] = 0.2820947917738781f;
  pSH[2] = 0.4886025119029199f * fZ;
  pSH[6] = 0.9461746957575601f * fZ2 + -0.3153915652525201f;
  fC0 = fX;
  fS0 = fY;
  fTmpA = -0.48860251190292f;
  pSH[3] = fTmpA * fC0;
  pSH[1] = fTmpA * fS0;
  fTmpB = -1.092548430592079f * fZ;
  pSH[7] = fTmpB * fC0;
  pSH[5] = fTmpB * fS0;
  fC1 = fX*fC0 - fY*fS0;
  fS1 = fX*fS0 + fY*fC0;
  fTmpC = 0.5462742152960395f;
  pSH[8] = fTmpC * fC1;
  pSH[4] = fTmpC * fS1;
  return pSH;
}

//This function is from https://github.com/kishimisu/Gaussian-Splatting-WebGL/blob/main/shaders/splat_vertex.glsl
vec3 computeCov2D(vec3 mean, float focal_x, float focal_y, float tan_fovx, float tan_fovy, float[6] cov3D, mat4 viewmatrix) {
    vec4 t = viewmatrix * vec4(mean, 1.0);

    float limx = 1.3 * tan_fovx;
    float limy = 1.3 * tan_fovy;
    float txtz = t.x / t.z;
    float tytz = t.y / t.z;
    t.x = min(limx, max(-limx, txtz)) * t.z;
    t.y = min(limy, max(-limy, tytz)) * t.z;

    mat3 J = mat3(
        focal_x / t.z, 0, -(focal_x * t.x) / (t.z * t.z),
        0, focal_y / t.z, -(focal_y * t.y) / (t.z * t.z),
        0, 0, 0
    );

    mat3 W =  mat3(
        viewmatrix[0][0], viewmatrix[1][0], viewmatrix[2][0],
        viewmatrix[0][1], viewmatrix[1][1], viewmatrix[2][1],
        viewmatrix[0][2], viewmatrix[1][2], viewmatrix[2][2]
    );


    mat3 c = mat3(
        cov3D[0], cov3D[1], cov3D[2],
        cov3D[1], cov3D[3], cov3D[4],
        cov3D[2], cov3D[4], cov3D[5]
    );

    mat3 T = W * J;

    mat3 Vrk = mat3(
        cov3D[0], cov3D[1], cov3D[2],
        cov3D[1], cov3D[3], cov3D[4],
        cov3D[2], cov3D[4], cov3D[5]
    );

    mat3 cov = transpose(T) * transpose(Vrk) * T;

    cov[0][0] += .3;
    cov[1][1] += .3;
    return vec3(cov[0][0], cov[0][1], cov[1][1]);}

void main() {
  uint splatIndex = gl_GlobalInvocationID.x;

  if (splatIndex < splats.length()) {
    Splat splat = splats[splatIndex];
    // Position
    vec3 originalPosition = splat.position;
    vec4 clipPos = ProjectionMatrix * ViewMatrix * vec4(originalPosition, 1.0f);
    computedSplats[splatIndex].transformedPosition = clipPos.xyz / clipPos.w;

    // Color
    vec3 direction = normalize(originalPosition);
    float sPH[9] = SHNewEval3(direction.x, direction.y, direction.z);
    vec3 c = 0.5 + vec3(splat.f_values[0], splat.f_values[1], splat.f_values[2]);
    for(int i = 1; i < 9; i++) {
      float redC = splat.f_values[3+i-1];
      float greenC = splat.f_values[3+15+i-1];
      float blueC = splat.f_values[3+2*15+i-1]; 
      c += sPH[i] * vec3(redC, greenC, blueC); 
    }
    computedSplats[splatIndex].color = vec4(c.r, c.g, c.b, 1.0);

    // Covariance
    vec3 covariance = computeCov2D(splat.position, focal_x, focal_y, tan_fovx, tan_fovy, splat.covariance, ViewMatrix);

    // Invert covariance (EWA algorithm)
    float det = (covariance.x * covariance.z - covariance.y * covariance.y);
    float det_inv = 1. / det;
    vec3 conic = vec3(covariance.z, -covariance.y, covariance.x) * det_inv;

    computedSplats[splatIndex].cov = covariance;
    computedSplats[splatIndex].conic = conic;

  }
}

