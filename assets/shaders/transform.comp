#version 430 core

layout(local_size_x = 64) in; //64 Seems to be normal, I don't know too much about this stuff

struct Splat {
  vec3 position;
  vec3 normal;
  float f_values[45]; // Coefficients for a Spherical Harmonics
                               // function defining color
  float opacity;
  vec3 scale;
  vec4 rotation;
};

struct ComputeOutput {
  vec3 transformedPosition;
  vec4 color;
};

// SSBO to store original splat data
layout(std430, binding = 0) buffer Splats {
  Splat splats[];
};

// SSBO to store transformed splat positions
layout(std430, binding = 1) buffer TransformedSplats {
  ComputeOutput computedSplats[];
};

uniform vec4 ViewMatrix;
uniform vec4 ProjectionMatrix;

// Peter-Pike Sloan, Efficient Spherical Harmonic Evaluation, Journal of Computer Graphics Techniques (JCGT), vol. 2, no. 2, 84-90, 2013 Available online http://jcgt.org/published/0002/02/06/

float[9] SHNewEval3(const float fX, const float fY, const float fZ) {
  float fC0, fC1, fS0, fS1, fTmpA, fTmpB, fTmpC;
  float fZ2 = fZ * fZ;
  float pSH[9];
  pSH[0] = 0.2820947917738781f;
  pSH[2] = 0.4886025119029199f * fZ;
  pSH[6] = 0.9461746957575601f * fZ2 + -0.3153915652525201f;
  fC0 = fX;
  fS0 = fY;
  fTmpA = -0.48860251190292f;
  pSH[3] = fTmpA * fC0;
  pSH[1] = fTmpA * fS0;
  fTmpB = -1.092548430592079f * fZ;
  pSH[7] = fTmpB * fC0;
  pSH[5] = fTmpB * fS0;
  fC1 = fX*fC0 - fY*fS0;
  fS1 = fX*fS0 + fY*fC0;
  fTmpC = 0.5462742152960395f;
  pSH[8] = fTmpC * fC1;
  pSH[4] = fTmpC * fS1;
  return pSH;
}

void main() {
  uint splatIndex = gl_GlobalInvocationID.x;

  if (splatIndex < splats.length()) {
    Splat splat = splats[splatIndex];
    // Position
    vec3 originalPosition = splat.position;
    vec4 clipPos = ProjectionMatrix * ViewMatrix * vec4(originalPosition, 1.0f);
    computedSplats[splatIndex].transformedPosition = vec3(clipPos / clipPos.w);

    // Color
    vec3 direction = normalize(originalPosition);
    float sPH[9] = SHNewEval3(direction.x, direction.y, direction.z);
    vec3 c = 0.5 + vec3(splat.f_values[0], splat.f_values[1], splat.f_values[2]);
    for(int i = 1; i < 9; i++) {
      float redC = splat.f_values[3+i-1];
      float greenC = splat.f_values[3+15+i-1];
      float blueC = splat.f_values[3+2*15+i-1]; 
      c += sPH[i] * vec3(redC, greenC, blueC); 
    }
    computedSplats[splatIndex].color = vec4(c.r, c.g, c.b, 1.0);
  }
}

